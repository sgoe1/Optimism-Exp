<!doctype html>
<html>
  <head>
    <title>Product Manager</title>
    <meta name="author" content="Sidharth Goel">
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="js/jspsych.js"></script>
    <script src="chart/Chart.js"></script>
    <script src="js/plugins/jspsych-text.js"></script>
    <script src="js/plugins/jspsych-single-stim.js"></script>
    <script src="js/plugins/jspsych-call-function.js"></script>
    <script src="js/plugins/jspsych-html.js"></script>
    <link href="css/jspsych.css" rel="stylesheet" type="text/css"></link>
  </head>
  <body>
          <div id='jspsych-target'></div> 
          <div class="center-content">
            <canvas id="myChart" width="400" height="400"></canvas>
          </div> 
  </body>
  <script type="text/javascript">

    // Note - some weirdness with naming conventions, but product->stages, test->simulations, experiment->phases
    // Dynamic variables - remember that any changes here need to also be reflected in test_run_block! (and also data.write)
    var money = 100000
    var timestep = 0
    var curr_stage = 0
    var most_recent_action = ""
    var most_recent_money = 0

    // Static variables
    var prod_a = "Product A"
    var prod_b = "Product B"
    var actions = {73: "invest", 77: "market"}
    var num_stages =  100 
    var goal_timestep = 12 //time horizon
    var init_money = money
    var invest_mean = -300    //mean and variance for reward upon investing
    var invest_variance = 20
    var market_mean = 800;  //mean and variance for reward upon marketing
    var market_variance = 50;
    var big_mean = 1500       //mean and variance for reward if prod B at final stage
    var big_variance = 20
    var bin_n = 100         //transition prob
    var bin_p = 0.02
    var test_timesteps = 2 //how many time steps per test simulation
    var test_stage_tracker = [0, 33, 66]
    var tracker_index = 0
    var money_points = [] //for graph display

    var condition = "optimism" //you can have "optimism", "realism", or "pessimism" here
    var condition_probs = {"optimism": 1.1, "realism": 1, "pessimism": 0.9} //can adjust level of optimism and pessimism
    var transition_prob_scaling = condition_probs[condition]
    var primed_condition = condition //
    var bin_mean = bin_n * bin_p

    /* intial instructions, before test run */
    var phase1_instructions = {
      type: "text",
      text: function(){
        var initialized_data = {
          type: 'parameters',
          actions: actions,
          num_stages: num_stages,
          goal_timestep: goal_timestep,
          init_money: init_money,
          invest_mean: invest_mean,
          invest_variance: invest_variance,
          market_mean: market_mean,
          market_variance: market_variance,
          big_mean: big_mean,
          big_variance: big_variance,
          bin_n: bin_n,
          bin_p: bin_p,
          test_timesteps: test_timesteps,
          condition_probs: condition_probs,
          condition: primed_condition
        }
      return "<p>You recently became product manager for your company, which currently sells " +
      "a product, " + prod_a + ". You are considering developing a new product, " + prod_b +" , which " +
      "is more lucrative than " + prod_a + " (higher profits). However, by choosing to invest in " + prod_b +
      " you lose money that month, but <i>potentially</i> make progress on " + prod_b + "'s development. Alternatively, "+
      " you can always choose to stall development of " + prod_b+ ", and just market " + prod_a + ", which you " +
      "know will earn you profits.</p>" + "<p>You are working over the course of " + goal_timestep + " months. The average return on marketing is $" + market_mean + ", while the average return on investing is $" + invest_mean + ". The average rate of development is " + bin_mean + "%. If you complete " + prod_b + " to 100% development, then you can market it for an average of $" + big_mean + "." + 
      "<p>Each month, you have to decide between <b>marketing " + prod_a +
      "</b> and <b>investing in " + prod_b + "</b>, with the goal of maximizing your total money by the end of the " + goal_timestep + " months. To invest, press 'I', to market press 'M'.</p>" + "<p>In the first phase, you will become familiar with the scenario in " + test_stage_tracker.length + " 'test simulations', each of which are " + test_timesteps + " months long. " +
      "We encourage you to explore the effects of investing and marketing in this phase, so you can make smart decisions in the actual experiment.</p><p>Once this phase is complete, you will proceed to the actual experiment. Press 'Enter' to proceed.</p>" + 
      "<div style='display:none;'>" + jsPsych.data.write(initialized_data) + "</div>"
      },
      cont_key: [13],
    };

    /* instructions before actual experiment */
    var phase2_instructions = {
      type: "text",
      text: "<p>You have completed the 'test simulations' and are now ready for the actual experiment. " +
            "Everything is reset - your money is $" + money +  ", your " + prod_b + " is %0 developed, and you will be working over the course of " + goal_timestep+ " months. And to reiterate some details from before, </p>" +
              "The average return on marketing is $" + market_mean + ", while the average return on investing is $" + invest_mean + ". The average rate of development is " + bin_mean + "%. If you complete " + prod_b + " to 100% development, then you can market it for an average of $" + big_mean + "." + 
            "<p>Proceed to the actual experiment (phase 2) by investing (I) or marketing (M). You begin with $" + money +".</p>",
      cont_key: [73, 77],
      //timing_post_trial: 2000
    };

    var prod0_phase = {
      type: "text",
      text: function() {
            var product_stage_message = ""
            var months_left = goal_timestep - timestep
            var original_stage = curr_stage
            getMostRecentKey()
            var gottenMoney = getMoney()
            if (actions[getMostRecentKey()] == 'invest'){
              product_stage_message = prod_b + " is now " + howDeveloped() + "% developed";
            }
            var trial_data = {
                type: 'real_experiment',
                money: money,
                timestep: timestep,
                curr_stage: curr_stage,
                action: most_recent_action,
                reward: most_recent_money,
            }
            return getMonthYear() + " - you have " + months_left + " months left." + "<p>" + prod_b+ " was "+howDeveloped(original_stage) + "% developed. You decided to <b>"+ actions[getMostRecentKey()] + "</b>. " + product_stage_message + "</p> " +
            "<p>This returns a profit of $" + gottenMoney + ", for a current total of $" + updateMoney() + ".</p>" + "<p>Press I to invest, M to market</p>" +
            "<div style='display:none;'>" +  jsPsych.data.write(trial_data) + "</div>"; //cleaner way to do this?

          },
      cont_key: [73, 77],
    };

    var prod0_test_phase = {
      type: "text",
      text: function() {
          var simulation = tracker_index +1
          return getMonthYear() + " - simulation " + simulation + "/" + test_stage_tracker.length + "<p>You currently have $" + money + " and your " + prod_b + " is %" + howDeveloped() + 
          " developed. Would you like to invest or market?</p>" + "<p>Press I to invest, M to market</p>";

          },
      cont_key: [73, 77],
    };

    var prod0_test_feedback = {
      type: "text",
      text: function() {
            var product_stage_message = ""
            var next_sim_msg = "Press enter to proceed."
            var original_stage = curr_stage
            getMostRecentKey()
            var gottenMoney = getMoney()
            var updatedMoney = updateMoney()
            if (actions[getMostRecentKey()] == 'invest'){
              product_stage_message = prod_b + " is now " + howDeveloped() + "% developed.";
            }
            if(timestep == test_timesteps-1 && tracker_index != test_stage_tracker.length-1){
              next_sim_msg =  "Press 'Enter' to proceed to next simulation."
            }
            var trial_data = {
                type: 'test_experiment',
                money: money,
                timestep: timestep,
                curr_stage: curr_stage,
                action: most_recent_action,
                reward: most_recent_money,
            }
            var new_stage = curr_stage
            return prod_b+ " was "+howDeveloped(original_stage) + "% developed. You decided to <b>"+ actions[getMostRecentKey()] + "</b>. " + product_stage_message + "</p>" +
            "<p>This returns a profit of $" + gottenMoney + ", for a current total of $" + updatedMoney + ".</p>" +
            next_sim_msg + "<div style='display:none;'>" + jsPsych.data.write(trial_data) + "</div>";
      },
      cont_key: [13],
    };

    var test_run_chunk = {
        chunk_type: 'while',
        timeline: [prod0_test_phase, prod0_test_feedback],
        continue_function: function(){
            if (tracker_index == test_stage_tracker.length-1 && timestep == test_timesteps-1){ //subtract by 1 because of start at 0. Couldnt use curr_stage == test_stage_tracker[test_stage_tracker.length-1], because curr_stage is updated
              return false;
            }

            else { 
              if(timestep == test_timesteps-1){
                timestep = 0
                tracker_index+=1
                curr_stage = test_stage_tracker[tracker_index] //resetting and incrementing
              }else{
                  timestep +=1
              }
              return true; 
            }
        }
    }

    // resets all variables that were changed in the test run, for the actual run
    var reset_block = {
      type: 'call-function',
      func: function(){ 
        money = 100000
        timestep = 0
        curr_stage = 0
        most_recent_action = ""
        most_recent_money = 0
        condition = "realism"
        transition_prob_scaling = condition_probs["realism"] 
        money_points = []
      }
    };

    var live_run_chunk = {
        chunk_type: 'while',
        timeline: [prod0_phase],
        continue_function: function(){
            timestep +=1
            if(timestep >= goal_timestep) {
              return false; 
            }
            else { return true; }
        }
    }

    var graph_block = {
      type: 'call-function',
      func: function(){
        var ctx = document.getElementById("myChart").getContext("2d");
        var data = {
          labels: Array.apply(null, {length: last_timestep}).map(Number.call, Number),
          datasets: [
              {
                  label: "Performance",
                  fillColor: "rgba(220,220,220,0.2)",
                  strokeColor: "rgba(220,220,220,1)",
                  pointColor: "rgba(220,220,220,1)",
                  pointStrokeColor: "#fff",
                  pointHighlightFill: "#fff",
                  pointHighlightStroke: "rgba(220,220,220,1)",
                  data: money_points
              },
          ]
        };
        var myLineChart = new Chart(ctx).Line(data);
      }
    }

    var debrief_block = {
      type: "text",
      text: function() {
        return "<p>In the course of " + goal_timestep + " months, you went from $"+ 
        init_money + " to $" + money + "</p><p>Thank you for your time!</p>";
      }
    };

    //Consent form
    var check_consent = function(elem) {
        if ($('#consent_checkbox').is(':checked')) {
            return true;
        }
        else {
            alert("If you wish to participate, you must check the box next to the statement 'I agree to participate in this study.'");
            return false;
        }
        return false;
    };        
    var consent_form = {type:'html', pages: [{url: 'consent.html', cont_btn: "start",check_fn: check_consent}]};

    function getMostRecentKey(){
      var trials = jsPsych.data.getTrialsOfType('text');
      var most_recent_trial = trials[trials.length - 1]
      if (typeof(most_recent_trial) == "undefined"){
        return ""
      }
      most_recent_action = actions[most_recent_trial['key_press']]
      return most_recent_trial['key_press'];

    }

    //Returns money for specific action - scales prob by condition (pess, opt, real)
    function getMoney(){
      if(most_recent_action == "invest"){
        var scaled_prob = bin_p * transition_prob_scaling
        curr_stage = Math.min(100, curr_stage + binomial(bin_n, scaled_prob))
        most_recent_money = normal_random(invest_mean, invest_variance); //returns reward
      }
      if(most_recent_action == "market"){    //returns reward based on current stage of product
        if(curr_stage == num_stages){ //final stage should return bigger reward
          most_recent_money = normal_random(big_mean, big_variance)
        }else{  //intermediate stages should return reward with same dist.
          most_recent_money = normal_random(market_mean, market_variance);
        }
      }
      return most_recent_money;
    }

    //Returns total amount of money after taking action
    function updateMoney(){
      money += most_recent_money
      money_points.push(money)
      return money;
    }

    function getMonthYear(){
      var day = new Date()
      var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
      var month = months[Math.floor(day.getMonth() + timestep)%12]
      var year = day.getFullYear() + Math.floor((timestep+day.getMonth())/12)
      return month + " " + year
    }

    function howDeveloped(a){
      if (a == undefined){
        a = curr_stage
      }
      return (a/num_stages * 100).toFixed(2)
    }

    //Returns normally distributed values
    function normal_random(mean, variance) {
      if (mean == undefined)
        mean = 0.0;
      if (variance == undefined)
        variance = 1.0;
      var V1, V2, S;
      do {
        var U1 = Math.random();
        var U2 = Math.random();
        V1 = 2 * U1 - 1;
        V2 = 2 * U2 - 1;
        S = V1 * V1 + V2 * V2;
      } while (S > 1);

      X = Math.sqrt(-2 * Math.log(S) / S) * V1;
      X = mean + Math.sqrt(variance) * X;
      return Math.round(X);
    }

    //Returns sample from binomial distribution
    function binomial(n, p){
      var x = 0;
      for(var i=0; i<n; i++){
        if(Math.random() < p){
          x++;
        }
      }
      return x
    }

    // defining the experiment
    var experiment = [];
    //experiment.push(consent_form);
    experiment.push(phase1_instructions);
    experiment.push(test_run_chunk);
    experiment.push(reset_block);
    experiment.push(phase2_instructions);
    experiment.push(live_run_chunk);
    //experiment.push(graph_block);
    experiment.push(debrief_block);

    jsPsych.init({
      display_element: $('#jspsych-target'),
      experiment_structure: experiment,
      // on_finish: function() {
      //   jsPsych.data.displayData();
      //   var data_as_csv = jsPsych.data.dataAsCSV();
      // }
    });
  </script>
</html>